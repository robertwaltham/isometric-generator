<!DOCTYPE HTML>
<html>
<head>
    <title>Generator</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000000;
        }
    </style>
    <script src="resources/pixi.dev.js"></script>
    <script src="resources/jquery-2.1.1.js"></script>
    <script src="resources/jquery-ui-1.11.1/jquery-ui.js"></script>
    <link href="resources/jquery-ui-1.11.1/jquery-ui.css" rel="stylesheet" type="text/css" title="Jquery UI">
    <link href="resources/jquery-ui-1.11.1/jquery-ui.css" rel="stylesheet" type="text/css" title="Jquery UI">
    <link href="resources/jquery-ui-1.11.1/jquery-ui.structure.css" rel="stylesheet" type="text/css" title="Jquery UI">
    <link href="resources/jquery-ui-1.11.1/jquery-ui.theme.css" rel="stylesheet" type="text/css" title="Jquery UI">

</head>
<body>

<script>

    var Generator = {
        options:{
            view_tc_width:25,
            view_tc_height:25,
            tile_count_x:50,
            tile_count_y:50,
            tile_half_x: 20,
            tile_half_y: 10,
            tile_base_scale: 0.4,
            offset_x: 640,
            offset_y: 64,
            canvas_width: 1280,
            canvas_height: 900,
            sprite_anchor: 0.5,
            texture_paths:{
                dirt:"resources/road/dirt.png",
                grass:"resources/road/grass.png",
                lot:"resources/road/lot.png",
                east:"resources/road/lotCornerEast.png",
                west:"resources/road/lotCornerWest.png",
                north:"resources/road/lotCornerNorth.png",
                south:"resources/road/lotCornerSouth.png"

            },
            texture_index:['dirt', 'grass', 'lot']
        },
        textures:[],
        tiles:[],
        tileParent:null,
        sprites:[],
        controls:[],
        highlightedTile:null,
        viewOrigin:{x:0, y:0},
        text:{
            fps:null,
            click:null,
            viewport:null
        },
        time:0,
        frame_count:0,
        stage:null,
        renderer:null,
        init:function(options){

            // First, checks if it isn't implemented yet.
            if (!String.prototype.format) {
                String.prototype.format = function() {
                    var args = arguments;
                    return this.replace(/{(\d+)}/g, function(match, number) {
                        return typeof args[number] != 'undefined'
                                ? args[number]
                                : match
                                ;
                    });
                };
            }


            // extend options
            $.extend(this.options, {}, options);

            console.log(this.options);

            // load textures
            for(var key in this.options.texture_paths){
                this.textures[key] = PIXI.Texture.fromImage(this.options.texture_paths[key]);
            }

            // create an new instance of a pixi stage
            this.stage = new PIXI.Stage(0x66FF99, true);
            this.stage.interactive = true;

            //tile parents
            this.tileParent = new PIXI.DisplayObjectContainer();
            this.tileParent.width = this.options.canvas_width;
            this.tileParent.height = this.options.canvas_height;
            this.tileParent.interactive = true;
            this.stage.addChild(this.tileParent);

            //tiles
            this.tiles = this.lib.generateTiles(this.options, this.tileParent);


            //text
            this.text.fps = new PIXI.Text("-", {font:"26px Arial", fill:"black"});
            this.text.click = new PIXI.Text("-", {font:"26px Arial", fill:"black"});
            this.text.click.position.y = 30;
            var rect = this.lib.getViewRect();
            this.text.viewport = new PIXI.Text("", {font:"26px Arial", fill:"black"});
            this.text.viewport.position.y = 60;

            //controls
            this.controls['north'] = new PIXI.Sprite(this.textures.north);
            this.controls['north'].shift = {x:0, y:-1};

            this.controls['south'] = new PIXI.Sprite(this.textures.south);
            this.controls['south'].shift = {x:0, y:1};

            this.controls['west'] = new PIXI.Sprite(this.textures.west);
            this.controls['west'].shift = {x:-1, y:0};

            this.controls['east'] = new PIXI.Sprite(this.textures.east);
            this.controls['east'].shift = {x:1, y:0};


            var i = 100;
            for(var ctrl in this.controls){
                this.controls[ctrl].interactive = true;
                this.controls[ctrl].name = ctrl;
                this.controls[ctrl].scale = new PIXI.Point(0.4, 0.4);
                this.controls[ctrl].mousedown = function(data){
                    Generator.lib.shiftView(this.shift.x, this.shift.y);

                    this.alpha = 0.75;
                };
                this.controls[ctrl].mouseup = this.controls[ctrl].mouseout = function(data){
                    this.alpha = 1;
                };
                this.controls[ctrl].position.y = i;
                this.controls[ctrl].position.x = 10;
                i += 30;
            }


            this.tileParent.mousedown = function(data){
                var pos = data.getLocalPosition(this);
                var tile = Generator.lib.isometricToOrtho(pos.x, pos.y,
                        Generator.options.tile_half_x,
                        Generator.options.tile_half_y,
                        Generator.options.offset_x,
                        Generator.options.offset_y,
                        Generator.options.sprite_anchor);
                if(tile.x > -1 && tile.y > -1 && tile.x < Generator.options.tile_count_x && tile.y < Generator.options.tile_count_y){
                    Generator.text.click.setText('x: ' + tile.x + ' y:' + tile.y);
                    if(this.highlightedTile){
                        this.highlightedTile.sprite.alpha = 1.0;
                    }
                    this.highlightedTile = Generator.tiles[tile.x][tile.y];
                    this.highlightedTile.sprite.alpha = 0.5;
                }
            };

            for(var text_label in this.text){
                this.stage.addChild(this.text[text_label]);
            }

            for(var control in this.controls){
                this.stage.addChild(this.controls[control]);
            }

            this.renderer = PIXI.autoDetectRenderer(this.options.canvas_width, this.options.canvas_height);

            // add the renderer view element to the DOM
            document.body.appendChild(this.renderer.view);

            this.time = Date.now();

            this.lib.shiftView(0,0);

            // set up renderer
            requestAnimFrame(this.lib.animate);

        },
        obj:{
            Tile:function(options, texture_def, x, y){
                this.sprite = Generator.lib.spriteFactory(options, Generator.textures[texture_def], x, y);
                this.x = x;
                this.y = y;
            }
        },
        lib:{
            shiftView:function(x, y){
                var shift = Generator.lib.orthoToIsometric(x , y, Generator.options.tile_half_x , Generator.options.tile_half_y, 0, 0 );


                Generator.tileParent.position.x +=  shift.x;
                Generator.tileParent.position.y +=  shift.y;

                Generator.viewOrigin.x -= x;
                Generator.viewOrigin.y -= y;

                for(var col in Generator.tiles){
                    for(var tile_index in Generator.tiles[col]){
                        var tile = Generator.tiles[col][tile_index];

                        var rect = Generator.lib.getViewRect();

                        if(tile.x > rect.x1 &&  tile.x < rect.x2 &&  tile.y > rect.y1 && tile.y < rect.y2){
                            tile.sprite.alpha = 1;
                            tile.sprite.visible = true;
                        }else if(((tile.x == rect.x1 || tile.x == rect.x2) && (tile.y >= rect.y1 &&tile.y <= rect.y2)) ||
                                ((tile.y == rect.y1 || tile.y == rect.y2) && (tile.x >= rect.x1 &&tile.x <= rect.x2))){
                            tile.sprite.alpha = 0.25;
                            tile.sprite.visible = true;

                        }else{
                            tile.sprite.alpha = 0;
                            tile.sprite.visible = false;
                        }
                    }
                }
                Generator.text.viewport.setText("({0}, {1}, {2}, {3} )".format(rect.x1, rect.x2, rect.y1, rect.y2));

            },
            getViewRect:function(){
                return {x1:Generator.viewOrigin.x,
                        x2:Generator.viewOrigin.x + Generator.options.view_tc_width,
                        y1:Generator.viewOrigin.y,
                        y2:Generator.viewOrigin.y + Generator.options.view_tc_height};
            },
            generateTiles:function(options, stage){
                var tiles = [];
                for(var x = 0; x < options.tile_count_x; x++){
                    var col = [];
                    for (var y = 0; y < options.tile_count_y; y++){
                        var index = Math.floor(Math.random() * 3);
                        var tile = new Generator.obj.Tile(options, Generator.options.texture_index[index], x, y);
                        col[y] = tile;
                        stage.addChild(tile.sprite);
                    }
                    tiles[x] = col;
                }
                return tiles;
            },
            spriteFactory:function(options, texture, x, y){
                var sprite = new PIXI.Sprite(texture);
                // center the sprites anchor point
                sprite.anchor.x = options.sprite_anchor;
                sprite.anchor.y = options.sprite_anchor;

                sprite.position = Generator.lib.orthoToIsometric(x, y,
                        options.tile_half_x,
                        options.tile_half_y,
                        options.offset_x,
                        options.offset_y);

                sprite.scale = new PIXI.Point(options.tile_base_scale, options.tile_base_scale);

                return sprite;
            },
            orthoToIsometric: function (x, y, half_width, half_height, offset_x, offset_y) {
                var u = (x - y) * half_width + offset_x;
                var v = (x + y) * half_height + offset_y;
                var w = x + y;
                return {x: u, y: v, z: w};
            },
            isometricToOrtho: function (u, v, half_width, half_height, offset_x, offset_y, sprite_anchor) {
                var _u = (u - offset_x) / half_width;
                var _v = (v - offset_y ) / half_height;

                var x = Math.floor(((_u + _v ) / 2) + sprite_anchor);
                var y = Math.floor(((_v - _u ) / 2) + sprite_anchor);
                return {x: x, y: y};
            },
            animate: function() {
                if(Generator.frame_count % 10 == 0){
                    var diff = (Date.now() - Generator.time) / 1000;
                    Generator.text.fps.setText(Math.round(1 / diff) + ' fps');
                }
                requestAnimFrame(Generator.lib.animate);

                // render the stage
                Generator.renderer.render(Generator.stage);
                Generator.time = Date.now();
                Generator.frame_count++;
            }
        }
    };

    $(document).ready(function(){
        Generator.init({});
    });

</script>
</body>
</html>